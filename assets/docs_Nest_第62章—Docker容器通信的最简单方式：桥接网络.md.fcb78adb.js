import{_ as s,v as a,b as n,R as p}from"./chunks/framework.eb2f4134.js";const D=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Nest/第62章—Docker容器通信的最简单方式：桥接网络.md","filePath":"docs/Nest/第62章—Docker容器通信的最简单方式：桥接网络.md"}'),e={name:"docs/Nest/第62章—Docker容器通信的最简单方式：桥接网络.md"},o=p(`<p>上节我们讲 Docker Compose 的时候，涉及到多个 docker 容器的通信，我们是通过指定宿主机 ip 和端口的方式。</p><p>因为 mysql、redis 的 Docker 容器都映射到了宿主机的端口，那 nest 的容器就可以通过宿主机来实现和其他容器的通信。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-1.png" alt=""></p><p>Docker 的实现原理那节我们讲过，Docker 通过 Namespace 的机制实现了容器的隔离，其中就包括 Network Namespace。</p><p>因为每个容器都有独立的 Network Namespace，所以不能直接通过端口访问其他容器的服务。</p><p>那如果这个 Network Namespace 不只包括一个 Docker 容器呢？？</p><p>可以创建一个 Network Namespace，然后设置到多个 Docker 容器，这样这些容器就在一个 Namespace 下了，不就可以直接访问对应端口了？</p><p>Docker 确实支持这种方式，叫做桥接网络。</p><p>通过 docker network 来创建：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker network create common-network</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-2.png" alt=""></p><p>然后把之前的 3 个容器停掉、删除，我们重新跑：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker stop mysql-container redis-container nest-container</span></span>
<span class="line"><span style="color:#A6ACCD;">docker rm mysql-container redis-container nest-container</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-3.png" alt=""></p><p>这次跑的时候要指定 --network：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker run -d --network common-network -v /Users/guang/mysql-data:/var/lib/mysql --name mysql-container mysql</span></span></code></pre></div><p>通过 --network 指定桥接网络为我们刚创建的 common-network。</p><p>不需要指定和宿主机的端口映射。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-4.png" alt="image.png"></p><p>然后跑 redis 容器：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker run -d --network common-network -v /Users/guang/aaa:/data --name redis-container redis</span></span></code></pre></div><p>同样也不需要指定和宿主机的端口映射，只需要指定挂载的数据卷就行：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-5.png" alt=""></p><p>然后 nest 的部分我们要改下代码：</p><p>修改 AppModule 的代码，改成用容器名来访问：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-6.png" alt=""></p><p>然后 docker build：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker build -t mmm .</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-7.png" alt=""></p><p>之后 docker run：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker run -d --network common-network -p 3000:3000 --name nest-container mmm</span></span></code></pre></div><p>nest 容器是要指定和宿主机的端口映射的，因为宿主机要访问这个端口的网页。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-8.png" alt=""></p><p>然后 docker logs 看下日志：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker logs nest-container</span></span></code></pre></div><p>可以看到打印了 sql 语句，说明 mysql 连接成功了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-9.png" alt=""></p><p>浏览器访问 <a href="http://localhost:3000" target="_blank" rel="noreferrer">http://localhost:3000</a></p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-10.png" alt=""></p><p>然后再看下日志：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker logs nest-container</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-11.png" alt=""></p><p>打印了 redis 的 key 说明 redis 服务也连接成功了。</p><p>这就是桥接网络。</p><p>之前我们是通过宿主机 ip 来互相访问的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-12.png" alt=""></p><p>现在可以通过容器名直接互相访问了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-13.png" alt=""></p><p>原理前面讲过，就是 Namespace。</p><p>本来是 3 个独立的 Network Namespace：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-14.png" alt=""></p><p>桥接之后就这样了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-15.png" alt=""></p><p>Namespace 下包含多个子 Namespace，互相能通过容器名访问。</p><p>比起端口映射到宿主机，再访问宿主机 ip 的方式，简便太多了。</p><p>那在 Docker Compose 里怎么使用这种方式呢？</p><p>之前我们是这样写的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-16.png" alt=""></p><p>现在改成这样：</p><div class="language-yml"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F07178;">version</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">3.8</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">services</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">nest-app</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">build</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#F07178;">context</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">./</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#F07178;">dockerfile</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">./Dockerfile</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">depends_on</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">mysql-container</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">redis-container</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">ports</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">3000:3000</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">networks</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">common-network</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">mysql-container</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">image</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">mysql</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">volumes</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/Users/guang/mysql-data:/var/lib/mysql</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">networks</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">common-network</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">redis-container</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">image</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">redis</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">volumes</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/Users/guang/aaa:/data</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">networks</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">common-network</span></span>
<span class="line"><span style="color:#F07178;">networks</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">common-network</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">driver</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">bridge</span></span></code></pre></div><p>version 是指定 docker-compose.yml 的版本，因为不同版本配置不同。</p><p>把 mysql-container、redis-container 的 ports 映射去掉，指定桥接网络为 common-network。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-17.png" alt=""></p><p>然后下面通过 networks 指定创建的 common-network 桥接网络，网络驱动程序指定为 bridge。</p><p>其实我们一直用的网络驱动程序都是 bridge，它的含义是容器的网络和宿主机网络是隔离开的，但是可以做端口映射。比如 -p 3000:3000、-p 3306:3306 这样。</p><p>然后执行：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker-compose down --rmi all</span></span></code></pre></div><p>就会删除 3 个容器和它们的镜像：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-18.png" alt=""></p><p>之后再</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker-compose up</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-19.png" alt=""></p><p>可以看到，会先 build dockerfile 产生镜像，然后把 3 个镜像跑起来。</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-20.png" alt=""></p><p>看到打印的 sql 说明 mysql 服务连接成功了。</p><p>（这个过程可能因为 mysql 容器没跑起来而连接失败几次，等一会就好了）</p><p>浏览器访问下：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-21.png" alt=""></p><p>也拿到了 redis 的 key，说明 redis 服务跑成功了：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-22.png" alt=""></p><p>这就是在 docker-compose 里使用桥接网络的方式。</p><p>不过，其实不指定 networks 也可以，docker-compose 会创建个默认的。</p><p>先把容器、镜像删掉：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">docker-compose down --rmi all</span></span></code></pre></div><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-23.png" alt=""></p><p>把 networks 部分注释掉，重新跑：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-24.png" alt=""></p><p>你会发现它创建了一个默认的 network：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-25.png" alt=""></p><p>mysql 和 redis 的访问都是正常的：</p><p><img src="//liushuaiyang.oss-cn-shanghai.aliyuncs.com/nest-docs/image/第62章-26.png" alt=""></p><p>所以，不手动指定 networks，也是可以用桥接网络的。</p><p>案例代码在<a href="https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/docker-compose-test" target="_blank" rel="noreferrer">小册仓库</a>。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>上节我们是把 mysql、redis 的端口映射到宿主机，然后 nest 的容器里通过宿主机 ip 访问这两个服务的。</p><p>但其实有更方便的方式，就是桥接网络。</p><p>通过 docker network create 创建一个桥接网络，然后 docker run 的时候指定 --network，这样 3 个容器就可以通过容器名互相访问了。</p><p>在 docker-compose.yml 配置下 networks 创建桥接网络，然后添加到不同的 service 上即可。</p><p>或者不配置 networkds，docker-compose 会生成一个默认的。</p><p>实现原理就是对 Network Namespace 的处理，本来是 3个独立的 Namespace，当指定了 network 桥接网络，就可以在 Namespace 下访问别的 Namespace 了。</p><p>多个容器之间的通信方式，用桥接网络是最简便的。</p>`,101),l=[o];function c(t,i,r,y,g,m){return a(),n("div",null,l)}const u=s(e,[["render",c]]);export{D as __pageData,u as default};
